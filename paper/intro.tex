\section{Introduction}

Recent years have a seen a rapid growth in the adoption of serverless computing
by industry. Serverless platforms, pioneered by AWS Lambda, offer a combination
of zero up-front cost, low maintenance, and a pay-as-you-go pricing model that
allows low-cost software deployment % Cite papers on serverless savings.

Serverless platforms, also known as Functions-as-a-Service (FaaS), are cloud
computing services that let users upload functions to the cloud, and define
events, such as http requests, that trigger those functions. The cloud provider
is then responsible for monitoring events, instantiating the execution
environment (e.g. spinning up a vm that matches the function requirements), and
invoking the function on the event inputs. 

In order to facilitate this execution model, serverless functions must conform
to some technical restrictions: serverless functions must be stateless, and
short-lived. Serverless platforms do not make any guarantees on the reuse of
execution environments, and consequently, a developer cannot rely on the state
of the execution being preserved across invocations. Additionally, for technical
reasons serverless function execution running times are capped (300s for most
cloud providers).

The main difference between serverless applications and traditional, monolithic
applications is the event-driven programming model. While event-driven
programming exists since at least the early 90s, it has not gained popularity
outside of the domains of GUI and hardware programming. The main barrier for
adoption being the the non-standard programming model, and the complexity of
debugging event-driven applications. The vicious cycle of lack of popularity
that leads to a lack of proper tooling that would otherwise ease the development
process certainly did not help.

The advent of serverless computing, with its myriad of benefits, seems to be
forcing the hand of programmers and finally pushing event-driven programming
into the mainstream. Once software developers migrate to serverless computing,
however, they are forced to contend with this lack of debug tools, on top of the
need to switch programming paradigms. Consequently, they tend to resort to the
most basic debug technique know to man---log printouts.



% A few paragraph on whay debug is hard
%
%   First, debug of detached, ephemeral, timed applications that you cannot
%   connect to.
%
%   Second, the problem of tracing data provenance across function invocations
%
%   Third, handling data-races and relaxed consistency guarantees in distributed
%   databases
%

% A few paragraphs on the proposed solution
%
%   First, an explanation of the recording framework
%
%   Second, a discussion on the replay part of the framework
%      * Replay of a single (stateless) function
%      * Handling state in functions
%      * Data provenance causality jumps
%
%   Third, handling databases
%
