\section{Introduction}

Recent years have a seen a rapid growth in the adoption of serverless computing
by industry. Serverless platforms, pioneered by AWS Lambda, offer a combination
of zero up-front cost, low maintenance, and a pay-as-you-go pricing model that
allows low-cost software deployment % Cite papers on serverless savings.

Serverless platforms, also known as Functions-as-a-Service (FaaS), are cloud
computing services that let users upload functions to the cloud, and define
events, such as http requests, that trigger those functions. The cloud provider
is then responsible for monitoring events, instantiating the execution
environment (e.g. spinning up a vm that matches the function requirements), and
invoking the function on the event inputs. 

In order to facilitate this execution model, serverless functions must conform
to some technical restrictions: serverless functions must be stateless, and
short-lived. Serverless platforms do not make any guarantees on the reuse of
execution environments, and consequently, a developer cannot rely on the state
of the execution being preserved across invocations. Additionally, for technical
reasons serverless function execution running times are capped (300s for most
cloud providers).

The main difference between serverless applications and traditional, monolithic
applications is the event-driven programming model. While event-driven
programming exists since at least the early 90s, it has not gained popularity
outside of the domains of GUI and hardware programming. The main barrier for
adoption being the the non-standard programming model, and the complexity of
debugging event-driven applications. The vicious cycle of lack of popularity
that leads to a lack of proper tooling that would otherwise ease the development
process certainly did not help.

The advent of serverless computing, with its myriad of benefits, seems to be
forcing the hand of programmers and finally pushing event-driven programming
into the mainstream. Once software developers migrate to serverless computing,
however, they are forced to contend with this lack of debug tools, on top of the
need to switch programming paradigms. Consequently, they tend to resort to the
most basic debug technique know to man---log printouts.

The already-hard problem of debugging event-driven application is made
significantly harder by the setting of serverless computing. The ephemeral
nature of serverless function executions means that it is impossible to
determine, a-priori, on which machine a function will be executed. This makes
traditional techniques of remotely connecting to a running execution impossible
to apply to the serverless setting without explicit support from the platform
providers. Additionally, strict function timeouts mean that even if you
successfully connect to a running function, debugging it is a race against the
clock. Making matters even worse is the fact that no provider currently gives
the option of freezing the execution of the entire system, as is common when
debugging traditional multi-threaded applications. Thus, it is impossible to get
a snapshot of the whole system state, which makes understanding the behaviour of
the system as a whole a 

% A few paragraph on whay debug is hard
%
%   First, debug of detached, ephemeral, timed applications that you cannot
%   connect to.
%
%   Second, the problem of tracing data provenance across function invocations
%
%   Third, handling data-races and relaxed consistency guarantees in distributed
%   databases
%

% A few paragraphs on the proposed solution
%
%   First, an explanation of the recording framework
%
%   Second, a discussion on the replay part of the framework
%      * Replay of a single (stateless) function
%      * Handling state in functions
%      * Data provenance causality jumps
%
%   Third, handling databases
%
